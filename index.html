
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Fruit Catch</title>
<style>
    body {
        margin: 0;
        background: #f6f2e8;
        overflow: hidden;
    }
    canvas {
        display: block;
        background: #e8dfcf;
    }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ===== ç”»é¢ã‚µã‚¤ã‚ºã‚’å…¨ç”»é¢ã« =====
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ =====
let score = 0;
let timeLeft = 30; // åˆ¶é™æ™‚é–“ï¼ˆç§’ï¼‰
let gameOver = false;

// ===== ã‚«ã‚´ =====
const basket = {
    width: 80,
    height: 45,
    x: canvas.width / 2 - 40,
    y: canvas.height - 80,
    speed: 7,
    dx: 0
};

// ===== ã‚¢ã‚¤ãƒ†ãƒ  =====
const items = [];
const fruitList = ["ğŸ", "ğŸŒ", "ğŸ’", "ğŸ‡"];
const bomb = "ğŸ’£";

// ===== ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆ =====
function spawnItem() {
    const isBomb = Math.random() < 0.35; // çˆ†å¼¾å¤šã‚
    const size = 30;

    items.push({
        emoji: isBomb ? bomb : fruitList[Math.floor(Math.random() * fruitList.length)],
        x: Math.random() * (canvas.width - size),
        y: -30,
        size: size,
        speed: 2 + Math.random() * 2,
        isBomb: isBomb
    });
}

// ===== æç”» =====
function drawBasket() {
    ctx.fillStyle = "#8B4513";
    ctx.fillRect(basket.x, basket.y, basket.width, basket.height);
}

function drawItems() {
    ctx.font = "28px serif";
    items.forEach(item => {
        ctx.fillText(item.emoji, item.x, item.y);
    });
}

function drawUI() {
    ctx.fillStyle = "#000";
    ctx.font = "18px Arial";
    ctx.fillText("Score: " + score, 10, 30);
    ctx.fillText("Time: " + timeLeft, canvas.width - 90, 30);
}

// ===== ç§»å‹•å‡¦ç† =====
function moveBasket() {
    basket.x += basket.dx;
    if (basket.x < 0) basket.x = 0;
    if (basket.x + basket.width > canvas.width) {
        basket.x = canvas.width - basket.width;
    }
}

function moveItems() {
    items.forEach((item, i) => {
        item.y += item.speed;

        // å½“ãŸã‚Šåˆ¤å®š
        if (
            item.y + item.size > basket.y &&
            item.x + item.size > basket.x &&
            item.x < basket.x + basket.width
        ) {
            if (item.isBomb) {
                score -= 2;
                timeLeft -= 3;
                if (score < 0) score = 0;
                if (timeLeft < 0) timeLeft = 0;
            } else {
                score += 1;
            }
            items.splice(i, 1);
        }

        // ç”»é¢å¤–
        if (item.y > canvas.height) {
            items.splice(i, 1);
        }
    });
}

// ===== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— =====
function update() {
    if (gameOver) {
        ctx.fillStyle = "#000";
        ctx.font = "32px Arial";
        ctx.fillText("TIME UP", canvas.width / 2 - 80, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText("Score: " + score, canvas.width / 2 - 50, canvas.height / 2 + 40);
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (Math.random() < 0.04) spawnItem();

    moveBasket();
    moveItems();

    drawItems();
    drawBasket();
    drawUI();

    requestAnimationFrame(update);
}

// ===== ã‚¿ã‚¤ãƒãƒ¼ =====
const timer = setInterval(() => {
    if (!gameOver) {
        timeLeft--;
        if (timeLeft <= 0) {
            gameOver = true;
            clearInterval(timer);
        }
    }
}, 1000);

// ===== æ“ä½œ =====
document.addEventListener("keydown", e => {
    if (e.key === "ArrowLeft") basket.dx = -basket.speed;
    if (e.key === "ArrowRight") basket.dx = basket.speed;
});
document.addEventListener("keyup", () => basket.dx = 0);

// ã‚¹ãƒãƒ›æ“ä½œ
canvas.addEventListener("touchmove", e => {
    const rect = canvas.getBoundingClientRect();
    basket.x = e.touches[0].clientX - rect.left - basket.width / 2;
});

update();
</script>

</body>
</html>
